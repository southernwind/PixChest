using System.IO;
using System.IO.Compression;
using System.Threading.Tasks;
using ImageMagick;
using PixChest.Database.Tables;
using PixChest.FileTypes.Base.Models;
using PixChest.Models.Files.Metadata.Images;
using PixChest.Utils.Constants;
using PixChest.Utils.Enums;

namespace PixChest.FileTypes.Archive.Models;
[AddTransient]
public partial class ArchiveFileOperator : BaseFileOperator {

	public override MediaType TargetMediaType {
		get;
	} = MediaType.Archive;

	public override async Task<MediaFile?> RegisterFileAsync(string filePath) {
		using var lockObject = await LockObjectConstants.DbLock.LockAsync();
		using var transaction = await this._db.Database.BeginTransactionAsync();
		var isExists = await this._db.MediaFiles.AnyAsync(x => x.FilePath == filePath);
		if (isExists) {
			return null;
		}
		var thumbRelativePath = FilePathUtility.GetThumbnailRelativeFilePath(filePath);
		var thumbPath = FilePathUtility.GetThumbnailAbsoluteFilePath(thumbRelativePath);

		using var archiveFile = ZipFile.Open(filePath, ZipArchiveMode.Read);

		var first = archiveFile.Entries.FirstOrDefault(x => FilePathUtility.IsImageFile(x.Name));
		try {
			if (first != null) {
				var image = this.CreateThumbnail(archiveFile, 300, 300, first.FullName);
				new FileInfo(thumbPath).Directory?.Create();
				File.WriteAllBytes(thumbPath, image);
			}
		} catch (Exception) {
			thumbPath = null;
		}

		var fileInfo = new FileInfo(filePath);

		var mf = new MediaFile {
			DirectoryPath = Path.GetDirectoryName(filePath)!,
			FilePath = filePath,
			ThumbnailFileName = thumbRelativePath,
			Rate = -1,
			Description = "",
			IsAutoGeneratedThumbnail = true,
			FileSize = fileInfo.Exists ? fileInfo.Length : 0,
			CreationTime = fileInfo.Exists ? fileInfo.CreationTime : DateTime.MinValue,
			ModifiedTime = fileInfo.Exists ? fileInfo.LastWriteTime : DateTime.MinValue,
			LastAccessTime = fileInfo.Exists ? fileInfo.LastAccessTime : DateTime.MinValue,
			RegisteredTime = DateTime.Now,
			IsExists = fileInfo.Exists,
			Container = new() {
				PageCount = archiveFile.Entries.Count(x => FilePathUtility.IsImageFile(x.Name)),
			}
		};

		if (first != null) {
			try {
				using var stream = first!.Open();
				using var ms = new MemoryStream();
				stream.CopyTo(ms);
				ms.Seek(0, SeekOrigin.Begin);
				using var meta = ImageMetadataFactory.Create(ms);
				mf.Width = meta.Width;
				mf.Height = meta.Height;
			} catch (Exception) {
				mf.Width = 0;
				mf.Height = 0;
			}
		}

		await this._db.MediaFiles.AddAsync(mf);
		await this._db.SaveChangesAsync();
		await transaction.CommitAsync();

		return mf;
	}

	/// <summary>
	/// サムネイル作成
	/// </summary>
	/// <param name="archiveFile">ファイル</param>
	/// <param name="width">サムネイル幅</param>
	/// <param name="height">サムネイル高さ</param>
	/// <param name="fileName">サムネイルにするファイル名</param>
	/// <returns>作成されたサムネイルファイル</returns>
	public byte[] CreateThumbnail(ZipArchive archiveFile, uint width, uint height, string fileName) {
		using var ms = new MemoryStream();
		using var stream = archiveFile.Entries.FirstOrDefault(x => x.FullName == fileName)!.Open();
		using var mi = new MagickImage(stream);
		mi.AutoOrient();
		mi.Thumbnail(width, height);
		mi.Format = MagickFormat.Jpg;
		mi.Write(ms);
		return ms.ToArray();
	}
}
